{% extends "base.html" %}

{% block title %}Filter Engine Home{% endblock %}

{% block content %}
<div class="flex justify-center py-12 px-4 bg-gray-50 min-h-screen">
    <div class="max-w-4xl w-full space-y-12">
        <h1 class="text-4xl font-extrabold text-center text-gray-800">Welcome to the Filter Engine</h1>

        <p class="text-lg text-left text-gray-700">
            The Filter Engine is designed to provide a robust and efficient system for filtering products and data
            in multiple ways. It combines <strong>manual GET filtering</strong>, <strong>Django Filter integration</strong>, 
            and <strong>faceted search</strong> to allow both simple and complex filtering needs.
        </p>

        <!-- Step 0 -->
        <div class="bg-white p-6 rounded-2xl shadow-md space-y-4">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Step 0: Project Scaffold and Sample Data</h2>
            <p class="text-gray-700 text-left">
                Start by scaffolding the Django project and defining your core models such as <code>Product</code>, 
                <code>Category</code>, and <code>Brand</code>. Once migrations are applied, populate the database 
                with at least <strong>1000 sample products</strong> using <code>Faker</code> or <code>Factory Boy</code>. 
                This ensures realistic testing and reveals performance bottlenecks early.
            </p>
        </div>

        <!-- Step 1 -->
        <div class="bg-white p-6 rounded-2xl shadow-md space-y-4">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Step 1: QuerySets and Unit Tests</h2>
            <p class="text-gray-700 text-left">
                Work inside the Django shell to explore QuerySets for filtering by category, brand, and attributes. 
                Write unit tests to verify results—ensuring filters always return the expected data. These tests 
                act as a safety net when the filtering system becomes more complex.
            </p>
        </div>

        <!-- Step 2 -->
        <div class="bg-white p-6 rounded-2xl shadow-md space-y-4">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Step 2: Views & Templates with GET Filters</h2>
            <p class="text-gray-700 text-left">
                Wire up your views and templates to accept <strong>GET parameters</strong>. Filters such as 
                <code>?category=shoes&amp;brand=nike</code> make URLs meaningful and shareable. Add an 
                <strong>Apply</strong> button for users to update results, and integrate pagination to handle 
                large datasets efficiently.
            </p>
        </div>

        <!-- Step 3 -->
        <div class="bg-white p-6 rounded-2xl shadow-md space-y-4">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Step 3: Django Filter + Multi-Select Tags</h2>
            <p class="text-gray-700 text-left">
                Introduce <code>django-filter</code> for declarative backend filtering. This approach:
            </p>
            <ul class="list-disc ml-6 text-gray-700 space-y-1">
                <li>Encapsulates filter logic in <code>FilterSet</code> classes.</li>
                <li>Generates automatic forms, reducing template boilerplate.</li>
                <li>Produces clean, human-readable URLs like <code>?brand=nike&amp;color=red</code>.</li>
                <li>Supports multi-select with checkboxes, dropdowns, or tag-based UIs.</li>
                <li>Displays active filters as <strong>removable tags</strong> above the product list.</li>
            </ul>
        </div>

        <!-- Step 4 -->
        <div class="bg-white p-6 rounded-2xl shadow-md space-y-4">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Step 4: Faceting Sidebar + Multi-Select + Price Buckets</h2>

            <div class="space-y-2">
                <p class="text-gray-700 text-left">
                    Step 4 builds an advanced faceted search system. Users can select multiple categories, brands, statuses, and price ranges. The sidebar shows dynamic counts reflecting the current filter context.
                </p>

                <!-- UX Pattern 1 -->
                <div class="bg-gray-50 p-4 rounded-lg shadow-inner">
                    <h3 class="font-semibold text-gray-900">UX Pattern 1: Checkbox + Apply Button</h3>
                    <p class="text-gray-700">Classic approach where users select filters and click an "Apply" button to update results. Allows batching multiple selections before fetching data.</p>
                </div>

                <!-- UX Pattern 2 -->
                <div class="bg-gray-50 p-4 rounded-lg shadow-inner">
                    <h3 class="font-semibold text-gray-900">UX Pattern 2: Instant Filtering (AJAX)</h3>
                    <p class="text-gray-700">Filters update results instantly when a checkbox or dropdown changes. No "Apply" button is required. AJAX updates the product list and tag UI dynamically.</p>
                </div>

                <!-- UX Pattern 3 -->
                <div class="bg-gray-50 p-4 rounded-lg shadow-inner">
                    <h3 class="font-semibold text-gray-900">UX Pattern 3: Multi-Select Tags</h3>
                    <p class="text-gray-700">Active filters are displayed as removable tags above the product list. Clicking a tag removes that filter instantly, updating the results without a full page reload.</p>
                </div>

                <!-- UX Pattern 4 -->
                <div class="bg-gray-50 p-4 rounded-lg shadow-inner">
                    <h3 class="font-semibold text-gray-900">UX Pattern 4: Clear Filters</h3>
                    <p class="text-gray-700">A "Clear Filters" button resets all selected checkboxes, dropdowns, and tags. The page updates instantly via AJAX or redirects to a clean URL, ensuring users can start fresh.</p>
                </div>

                <p class="text-gray-700 mt-2">
                    Additional features:
                </p>
                <ul class="list-disc ml-6 text-gray-700">
                    <li>Sidebar counts recalc dynamically to reflect filtered results.</li>
                    <li>Price buckets categorize products (e.g., Under $50, $50–$100, etc.).</li>
                    <li>All URL parameters are shareable and reproduce the same filter state.</li>
                </ul>
            </div>
        </div>

        <!-- Step 5 -->
<div class="bg-white p-6 rounded-2xl shadow-md space-y-4">
    <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Step 5: Optimization and Performance</h2>
    
    <!-- Introduction -->
    <p class="text-gray-700">
        Step 5 focuses on making your filter engine production-ready and highly performant. 
        This includes optimizing database queries, preventing unnecessary extra queries (N+1 problems), 
        caching expensive computations, paginating results, monitoring query performance, 
        and optionally denormalizing data for super-fast facet counts. 
        Following these practices ensures a smooth and efficient user experience even with large datasets.
    </p>

    <div class="space-y-3">
        <h3 class="text-xl font-semibold text-gray-900">5.1 Add Indexes (Schema-Level)</h3>
        <p class="text-gray-700">
            Add indexes to frequently filtered fields such as <code>status</code>, <code>price</code>, and <code>created_at</code>.
            Consider composite indexes for common multi-column queries. Indexes speed up database reads but slightly increase write time.
            Always test queries and use tools like <strong>EXPLAIN</strong> or Django Debug Toolbar to ensure indexes are effective.
        </p>

        <h3 class="text-xl font-semibold text-gray-900">5.2 Avoid N+1 with <code>select_related</code> and <code>prefetch_related</code></h3>
        <p class="text-gray-700">
            Avoid N+1 query issues by using <code>select_related</code> for single-valued relationships (FK, OneToOne) 
            and <code>prefetch_related</code> for many-to-many or reverse FK relationships. 
            This ensures related objects are fetched in bulk, preventing extra queries in templates.
        </p>

        <h3 class="text-xl font-semibold text-gray-900">5.3 Cache Filtering Results & Facet Counts</h3>
        <p class="text-gray-700">
            Cache expensive computations like rendered product lists or facet counts. 
            Use Redis or Django's cache backend to store results keyed by filter parameters. 
            Invalidate caches on product create/update/delete, or use short TTLs to maintain freshness.
        </p>

        <h3 class="text-xl font-semibold text-gray-900">5.4 Pagination & Result Limits</h3>
        <p class="text-gray-700">
            Always paginate large result sets (e.g., 24–48 items per page) to avoid heavy queries and long render times. 
            When caching, include page number in the cache key so each page is cached separately.
        </p>

        <h3 class="text-xl font-semibold text-gray-900">5.5 Monitoring & Diagnostics</h3>
        <p class="text-gray-700">
            Use tools like Django Debug Toolbar during development to inspect query counts and performance. 
            In tests, measure query counts per view and template rendering using <code>CaptureQueriesContext</code>, 
            and enforce a query budget to catch regressions early.
        </p>

        <h3 class="text-xl font-semibold text-gray-900">5.6 Denormalization (Optional)</h3>
        <p class="text-gray-700">
            For high-traffic faceted filters, maintain denormalized counters like <code>Category.product_count</code> to avoid expensive COUNT() queries. 
            Update counts via signals on <code>post_save</code> and <code>post_delete</code> of products. 
            Ensure atomic updates and consider backfill commands to initialize counts for existing data.
        </p>

        <p class="text-gray-600 italic text-left">
            Following these optimizations ensures your filter engine is fast, efficient, and scalable, with minimal database queries, 
            accurate facet counts, and smooth UX even under heavy load.
        </p>
</div>


        <div class="text-center">
            <p class="text-gray-700">
                Navigate to the demo pages to explore <strong>manual GET filters</strong> and <strong>automatic faceted filters</strong> in action.
            </p>
        </div>
    </div>
</div>
{% endblock %}
